//
//  SphinxOnionManager.swift
//  
//
//  Created by James Carucci on 11/8/23.
//

import Foundation
import CocoaMQTT
import ObjectMapper

// Define a struct to represent the JSON structure
struct OnionConnectionData: Mappable {
    var scid: String?
    var serverPubkey: String?

    init?(map: Map) {}

    mutating func mapping(map: Map) {
        scid <- map["scid"]
        serverPubkey <- map["server_pubkey"]
    }
}


class SphinxOnionManager : NSObject {
    class var sharedInstance : SphinxOnionManager {
        struct Static {
            static let instance = SphinxOnionManager()
        }
        return Static.instance
    }
    
    let server_IP = "54.164.163.153"
    let server_PORT = 1883
    let test_mnemonic1 = "artist globe myself huge wing drive bright build agree fork media gentle"//TODO: stop using this in favor of one generated by user, backed up by hand and stored in secure memory
    let network = "regtest"
    
    var mqtt: CocoaMQTT! = nil
    
    var my_xpub : String?  {
        do{
            let seed = try mnemonicToSeed(mnemonic: test_mnemonic1)
            let xpub = try xpubFromSeed(seed: seed, time: getTimestampInMilliseconds(), network: network)
            return xpub
        }
        catch{
            return nil
        }
    }
    
    var my_only_keysend_pubkey : String? {
        do{
            let seed = try mnemonicToSeed(mnemonic: test_mnemonic1)
            let pubkey = try pubkeyFromSeed(seed: seed, idx: 0, time: getTimestampInMilliseconds(), network: network)
            return pubkey
        }
        catch{
            return nil
        }
    }
    
    func getTimestampInMilliseconds()->String{
        let nowSeconds = Date().timeIntervalSince1970
        let nowMilliseconds = Int64(nowSeconds * 1000)
        let nowMsString = String(nowMilliseconds)
        return nowMsString
    }    
    
    func createAccount(){
        do{
            //1. Generate Seed -> Display to screen the mnemonic for backup???
            let seed = try mnemonicToSeed(mnemonic: test_mnemonic1)
            //2. Create the 0th pubkey
            guard let pubkey = my_only_keysend_pubkey,
                  let my_xpub = my_xpub else{
                  return
            }
            //3. Connect to server/broker
            let now = getTimestampInMilliseconds()
            let sig = try rootSignMs(seed: seed, time: now, network: network)
            
            //4. Subscribe to relevant topics based on OK key
            let idx = 0
            mqtt = CocoaMQTT(clientID: my_xpub,host: server_IP ,port:  UInt16(server_PORT))
            mqtt.username = now
            mqtt.password = sig
            
            let success = mqtt.connect()
            print("mqtt.connect success:\(success)")
            
            if success{
                mqtt.didReceiveMessage = { mqtt, receivedMessage, id in
//                    print("MQTT message received with id:\(id) message:\(receivedMessage)")
//                    print("MQTT Topic:\(receivedMessage.topic) Payload:\(receivedMessage.payload)")
                    if receivedMessage.topic.contains("pubkey") || true {
                        let payloadData = Data(receivedMessage.payload)
                        if let payloadString = String(data: payloadData, encoding: .utf8) {
                            print("MQTT Topic:\(receivedMessage.topic) with Payload as String: \(payloadString)")
                            if let credentials = Mapper<OnionConnectionData>().map(JSONString: payloadString){
                                print("Onion Credentials register over MQTT:\(credentials)")
                                
                            }
//                            self.onionConfig.serverPubkey = serverPubkey
//                            self.onionConfig.destinationPubkey = "02058e8b6c2ad363ec59aa136429256d745164c2bdc87f98f0a68690ec2c5c9b0b"
                        } else {
                            print("MQTT Unable to convert payload to a string")
                        }
                    }
                    else if receivedMessage.topic.contains("register") {
                        let payloadData = Data(receivedMessage.payload)
                        if let serverPubkey = String(data: payloadData, encoding: .utf8) {
                            print("MQTT Payload as String: \(serverPubkey)")
//                            self.onionConfig.serverPubkey = serverPubkey
//                            self.onionConfig.destinationPubkey = "02058e8b6c2ad363ec59aa136429256d745164c2bdc87f98f0a68690ec2c5c9b0b"
                        } else {
                            print("MQTT Unable to convert payload to a string")
                        }
                    }
                    else{
                        //self.processReceivedOnionMessage(message: receivedMessage)
                    }
                }
                
                //subscribe to relevant topics
                mqtt.didConnectAck = { _, _ in
                    //self.showSuccessWithMessage("MQTT connected")
                    print("SphinxOnionManager: MQTT Connected")
                    API.sharedInstance.postMQTTStatusChange()
                    print("mqtt.didConnectAck")
                    
                    self.mqtt.subscribe([
                        ("\(pubkey)/\(idx)/res/#", CocoaMQTTQoS.qos1)
                    ])
                    
                    self.mqtt.publish(
                        CocoaMQTTMessage(
                            topic: "\(pubkey)/\(idx)/req/register",
                            payload: []
                        )
                    )
                    self.mqtt.publish(
                        CocoaMQTTMessage(
                            topic: "\(pubkey)/\(idx)/req/pubkey",
                            payload: []
                        )
                    )
                    self.mqtt.publish(
                        CocoaMQTTMessage(
                            topic: "\(pubkey)/\(idx)/req/balance",
                            payload: []
                        )
                    )
                    
                }
            }
        }
        catch{
            
        }
       
    }
    
    
}
