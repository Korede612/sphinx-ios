//
//  SphinxOnionManager.swift
//  
//
//  Created by James Carucci on 11/8/23.
//

import Foundation
import CocoaMQTT
import ObjectMapper
import SwiftyJSON


class SphinxOnionManager : NSObject {
    class var sharedInstance : SphinxOnionManager {
        struct Static {
            static let instance = SphinxOnionManager()
        }
        return Static.instance
    }
    
    var pendingContact : UserContact? = nil
    var currentServer : Server? = nil
    let newMessageBubbleHelper = NewMessageBubbleHelper()
    var shouldPostUpdates : Bool = false
    let server_IP = "54.164.163.153"
    let server_PORT = 1883
    //let test_mnemonic1 = "artist globe myself huge wing drive bright build agree fork media gentle"//TODO: stop using this in favor of one generated by user, backed up by hand and stored in secure memory
    let network = "regtest"
    var vc: UIViewController! = nil
    var mqtt: CocoaMQTT! = nil
    
    func getAccountSeed(mnemonic:String)->String?{
        do{
            let seed = try mnemonicToSeed(mnemonic: mnemonic)
            return seed
        }
        catch{
            print("error in getAccountSeed")
            return nil
        }
    }
    
    func generateMnemonic()->String?{
        var result : String? = nil
        do {
            result = try mnemonicFromEntropy(entropy: Data.randomBytes(length: 16).hexString)
            guard let result = result else{
                return nil
            }
            UserData.sharedInstance.save(walletMnemonic: result)
        }
        catch let error{
            print("error getting seed\(error)")
        }
        return result
    }
    
    func getAccountXpub(seed:String) -> String?  {
        do{
            let xpub = try xpubFromSeed(seed: seed, time: getTimestampInMilliseconds(), network: network)
            return xpub
        }
        catch{
            return nil
        }
    }
    
    func getAccountOnlyKeysendPubkey(seed:String)->String?{
        do{
            let pubkey = try pubkeyFromSeed(seed: seed, idx: 0, time: getTimestampInMilliseconds(), network: network)
            return pubkey
        }
        catch{
            return nil
        }
    }
    
    func getTimestampInMilliseconds()->String{
        let nowSeconds = Date().timeIntervalSince1970
        let nowMilliseconds = Int64(nowSeconds * 1000)
        let nowMsString = String(nowMilliseconds)
        return nowMsString
    }
    
    func connectToBroker(seed:String,xpub:String)->Bool{
        if let mqtt = mqtt{
            mqtt.disconnect()
        }
        
//        if mqtt?.connState == .connected || mqtt?.connState == .connecting {
//            showSuccessWithMessage("MQTT already connected or connecting")
//            return true
//        }
        do{
            let now = getTimestampInMilliseconds()
            let sig = try rootSignMs(seed: seed, time: now, network: network)
            
            mqtt = CocoaMQTT(clientID: xpub,host: server_IP ,port:  UInt16(server_PORT))
            mqtt.username = now
            mqtt.password = sig
            
            let success = mqtt.connect()
            print("mqtt.connect success:\(success)")
            return success
        }
        catch{
            return false
        }
    }
    
    func subscribeAndPublishTopics(pubkey:String,idx:Int){
        self.mqtt.subscribe([
            ("\(pubkey)/\(idx)/res/#", CocoaMQTTQoS.qos1)
        ])
        
        self.mqtt.publish(
            CocoaMQTTMessage(
                topic: "\(pubkey)/\(idx)/req/register",
                payload: []
            )
        )
        self.mqtt.publish(
            CocoaMQTTMessage(
                topic: "\(pubkey)/\(idx)/req/pubkey",
                payload: []
            )
        )
        self.mqtt.publish(
            CocoaMQTTMessage(
                topic: "\(pubkey)/\(idx)/req/balance",
                payload: []
            )
        )
    }
    
    
    func createAccount(mnemonic:String)->Bool{
        do{
            //1. Generate Seed -> Display to screen the mnemonic for backup???
            guard let seed = getAccountSeed(mnemonic: mnemonic) else{
                //possibly send error message?
                return false
            }
            //2. Create the 0th pubkey
            guard let pubkey = getAccountOnlyKeysendPubkey(seed: seed),
                  let my_xpub = getAccountXpub(seed: seed) else{
                  return false
            }
            //3. Connect to server/broker
            let success = connectToBroker(seed:seed,xpub: my_xpub)
            
            //4. Subscribe to relevant topics based on OK key
            let idx = 0
            if success{
                mqtt.didReceiveMessage = { mqtt, receivedMessage, id in
                    self.processMqttMessages(message: receivedMessage)
                }
                
                //subscribe to relevant topics
                mqtt.didConnectAck = { _, _ in
                    //self.showSuccessWithMessage("MQTT connected")
                    print("SphinxOnionManager: MQTT Connected")
                    print("mqtt.didConnectAck")
                    self.subscribeAndPublishTopics(pubkey: pubkey, idx: idx)
                }
            }
            return success
        }
        catch{
            print("error connecting to mqtt broker")
            return false
        }
       
    }
    
    func processRegisterTopicResponse(registerMessage:CocoaMQTTMessage){
        let payloadData = Data(registerMessage.payload)
        if let payloadString = String(data: payloadData, encoding: .utf8) {
            print("MQTT Topic:\(registerMessage.topic) with Payload as String: \(payloadString)")
            if let retrievedCredentials = Mapper<SphinxOnionBrokerResponse>().map(JSONString: payloadString){
                print("Onion Credentials register over MQTT:\(retrievedCredentials)")
                //5. Store my credentials (SCID, serverPubkey, myPubkey)
                if let _ = retrievedCredentials.scid{
                    processContact(from: registerMessage.topic,retrievedCredentials: retrievedCredentials)
                }
            }
        } else {
            print("MQTT Unable to convert payload to a string")
        }
    }
    
    func processBalanceUpdateMessage(balanceUpdateMessage:CocoaMQTTMessage){
        let payloadData = Data(balanceUpdateMessage.payload)
        if let payloadString = String(data: payloadData, encoding: .utf8) {
            print("MQTT Topic:\(balanceUpdateMessage.topic) with Payload as String: \(payloadString)")
            (shouldPostUpdates) ?  NotificationCenter.default.post(Notification(name: .onBalanceDidChange, object: nil, userInfo: ["balance" : payloadString])) : ()
        }
    }
    
    func processMqttMessages(message:CocoaMQTTMessage){
        let tops = message.topic.split(separator: "/")
        if tops.count < 4{
            return
        }
        let topic = tops[3]
        switch(topic){
        case "register":
            print("processing register topic!")
            processRegisterTopicResponse(registerMessage: message)
            break
        case "balance":
            print("processing balance topic!")
            processBalanceUpdateMessage(balanceUpdateMessage: message)
            break
        default:
            print("topic not in list:\(topic)")
            break
        }
    }
    
    func showSuccessWithMessage(_ message: String) {
        self.newMessageBubbleHelper.showGenericMessageView(
            text: message,
            delay: 6,
            textColor: UIColor.white,
            backColor: UIColor.Sphinx.PrimaryGreen,
            backAlpha: 1.0
        )
    }
}

extension SphinxOnionManager{//Sign Up UI Related:
    func chooseImportOrGenerateSeed(){
        let requestEnteredMneumonicCallback: (() -> ()) = {
            self.importSeedPhrase()
        }
        
        let generateSeedCallback: (() -> ()) = {
            guard let mneomnic = self.generateMnemonic(),
                  let vc = self.vc as? NewUserSignupFormViewController else{
                return
            }
            self.showMnemonicToUser(mnemonic: mneomnic, callback: {
                self.createAccount(mnemonic: mneomnic)
                vc.signup_v2_with_test_server()
            })
        }
        
        AlertHelper.showTwoOptionsAlert(
            title: "profile.mnemonic-generate-or-import-title".localized,
            message: "profile.mnemonic-generate-or-import-prompt".localized,
            confirmButtonTitle: "profile.mnemonic-generate-prompt".localized,
            cancelButtonTitle: "profile.mnemonic-import-prompt".localized,
            confirm: generateSeedCallback,
            cancel: requestEnteredMneumonicCallback
        )
    }
    
    func importSeedPhrase(){
        if let vc = self.vc as? ImportSeedViewDelegate {
            vc.showImportSeedView()
        }
    }
    
    func showMnemonicToUser(mnemonic: String, callback: @escaping () -> ()) {
        guard let vc = vc else {
            callback()
            return
        }
        
        let copyAction = UIAlertAction(
            title: "Copy",
            style: .default,
            handler: { _ in
                ClipboardHelper.copyToClipboard(text: mnemonic, message: "profile.mnemonic-copied".localized)
                callback()
            }
        )
        
        AlertHelper.showAlert(
            title: "profile.store-mnemonic".localized,
            message: mnemonic,
            on: vc,
            additionAlertAction: copyAction,
            completion: {
                callback()
            }
        )
    }
    
}

extension SphinxOnionManager{//contacts related
    func saveLSPServerData(retrievedCredentials:SphinxOnionBrokerResponse){
        let managedContext = CoreDataManager.sharedManager.persistentContainer.viewContext
        let server = Server(context: managedContext)

        server.pubKey = retrievedCredentials.serverPubkey
        server.ip = self.server_IP
        (shouldPostUpdates) ?  NotificationCenter.default.post(Notification(name: .onMQTTConnectionStatusChanged, object: nil, userInfo: ["server" : server])) : ()
        self.currentServer = server
        managedContext.saveContext()
    }
    
    func createSelfContact(scid:String,serverPubkey:String,myOkKey:String){
        let managedContext = CoreDataManager.sharedManager.persistentContainer.viewContext
        self.pendingContact = UserContact(context: managedContext)
        self.pendingContact?.scid = scid
        self.pendingContact?.isOwner = true
        self.pendingContact?.index = 0
        self.pendingContact?.publicKey = myOkKey
        self.pendingContact?.routeHint = "\(serverPubkey)_\(scid)"
        managedContext.saveContext()
    }
    
    func parseContactInfoString(routeHint:String)->(String,String,String)?{
        let components = routeHint.split(separator: "_").map({String($0)})
        return (components.count == 3) ? (components[0],components[1],components[2]) : nil
    }
    
    func addContact(contactInfo:String){
        guard let (recipientPubkey, recipLspPubkey,scid) = parseContactInfoString(routeHint: contactInfo) else{
            return
        }
        let routeHint = "\(recipLspPubkey)_\(scid)"
        guard let mnemonic = UserData.sharedInstance.getMnemonic(),
              let seed = getAccountSeed(mnemonic: mnemonic),
              let xpub = getAccountXpub(seed: seed),
              let nextIndex = UserContact.getNextAvailableContactIndex()
        else{
            return
        }
        let idx = UInt32(nextIndex)
        let time = getTimestampInMilliseconds()
        do{
            let childPubKey = try pubkeyFromSeed(seed: seed, idx: idx, time: time, network: network)
            let success = connectToBroker(seed: seed, xpub: xpub)
            if (success == false){return}
            
            createNewContact(pubkey: recipientPubkey, childPubkey: childPubKey, routeHint: routeHint, idx: nextIndex)
            
            mqtt.didReceiveMessage = { mqtt, receivedMessage, id in
                self.processMqttMessages(message: receivedMessage)
            }
            
            //subscribe to relevant topics
            mqtt.didConnectAck = { _, _ in
                //self.showSuccessWithMessage("MQTT connected")
                print("SphinxOnionManager: MQTT Connected")
                print("mqtt.didConnectAck")
                self.mqtt.subscribe([
                    ("\(childPubKey)/\(idx)/res/#", CocoaMQTTQoS.qos1)
                ])
                self.mqtt.publish(
                    CocoaMQTTMessage(
                        topic: "\(childPubKey)/\(idx)/req/register",
                        payload: []
                    )
                )
            }
        }
        catch{
            print("error: \(error)")
        }
    }
    
    func createNewContact(
        pubkey:String,
        childPubkey:String,
        routeHint:String,
        idx:Int,
        scid:String?=nil,
        publicKey:String?=nil
    ){
        let managedContext = CoreDataManager.sharedManager.persistentContainer.viewContext
        let contact = UserContact(context: managedContext)
        contact.publicKey = pubkey
        contact.childPubKey = childPubkey
        contact.routeHint = routeHint
        contact.index = idx
        contact.id = idx
        
        managedContext.saveContext()
    }
    
    func processContact(from mqttTopic:String, retrievedCredentials: SphinxOnionBrokerResponse){
        guard let topicParams = getValidatedRegisterTopicParams(topic:mqttTopic),
              let scid = retrievedCredentials.scid,
              let serverPubkey = retrievedCredentials.serverPubkey,
              let mnemonic = UserData.sharedInstance.getMnemonic(),
              let seed = getAccountSeed(mnemonic: mnemonic),
              let myPubkey = getAccountOnlyKeysendPubkey(seed: seed) else{
            AlertHelper.showAlert(title: "pub.key.options-add.contact.error.title".localized, message: "pub.key.options-add.contact.error.message".localized)
              return
          }
        if(mqttTopic.contains(myPubkey)){//"self" contact case
            let myOkKey = topicParams[0]
            createSelfContact(scid: scid, serverPubkey: serverPubkey,myOkKey: myOkKey)
            saveLSPServerData(retrievedCredentials: retrievedCredentials)//only save LSP if it's a self contact
        }
        else if let index = Int(topicParams[1]),
                let existingContact = UserContact.getContactWith(indices: [index]).first{
            existingContact.contactRouteHint = "\(serverPubkey)_\(topicParams[0])"
            existingContact.scid = scid
            CoreDataManager.sharedManager.saveContext()
            
            sendKeyExchangeMsg(to: existingContact)
        }
        else{//falls thorugh & should not hit..throw error
            print("error")
        }
    }
    
    func getValidatedRegisterTopicParams(topic:String) -> [String]?{
        let topicParams = topic.split(separator: "/")
        if topicParams.count != 4{
            AlertHelper.showAlert(title: "pub.key.options-add.contact.error.title".localized, message: "pub.key.options-add.contact.error.message".localized)
            return nil
        }
        return topicParams.map({String($0)})
    }
}


extension SphinxOnionManager{//Composing outgoing messages & processing incoming messages
    func sendKeyExchangeMsg(to contact: UserContact) -> SphinxMsgError? {
        guard let mnemonic = UserData.sharedInstance.getMnemonic(),
              let seed = getAccountSeed(mnemonic: mnemonic),
              let myOkKey = getAccountOnlyKeysendPubkey(seed: seed) else {
            return SphinxMsgError.credentialsError
        }
        guard let recipPubkey = contact.publicKey, // OK key
              let recipRouteHint = contact.contactRouteHint,
              recipRouteHint.split(separator: "_").count == 2 else {
            return SphinxMsgError.contactDataError
        }

        guard let selfContact = UserContact.getSelfContact(),
              let selfRouteHint = selfContact.routeHint else {
            return SphinxMsgError.credentialsError
        }
        let serverPubkey = recipRouteHint.split(separator: "_")[0]
        let scid = recipRouteHint.split(separator: "_")[1]

        let senderInfo : [String:String] = [
            "pubkey": myOkKey,
            "route_hint": selfRouteHint,
            "contact_pubkey": contact.childPubKey,
            "contact_route_hint": "0343f9e2945b232c5c0e7833acef052d10acf80d1e8a168d86ccb588e63cd962cd_529771090574245895",
            "alias": selfContact.nickname ?? "Satoshi Nakamoto",
            "photo_url": ""
        ]

        

        let hopsArray: [[String: String]] = [
            ["pubkey": "\(serverPubkey)"],
            ["pubkey": "\(recipPubkey)"]
        ]
        
        

        // Serialize the hopsArray to JSON
        guard let hopsJSON = try? JSONSerialization.data(withJSONObject: hopsArray, options: []),
              let hopsJSONString = String(data: hopsJSON, encoding: .utf8),
              let senderInfoJSON = try? JSONSerialization.data(withJSONObject: senderInfo),
              let senderInfoString = String(data: senderInfoJSON, encoding: .utf8) else {
            return SphinxMsgError.encodingError
        }
        
        let msg : [String:Any] = [
            "type": 10,
            "sender": senderInfo,
            "message":["content":""]
        ]
        
        guard let contentData = try? JSONSerialization.data(withJSONObject: msg),
              let contentJSONString = String(data: contentData, encoding: .utf8)
               else{
            return SphinxMsgError.encodingError
        }
        
        let time = getTimestampInMilliseconds()

        do {
            let onion = try! createOnionMsg(seed: seed, idx: UInt32(0), time: time, network: network, hops: hopsJSONString, json: contentJSONString)
            //let onion = try! createOnion(seed: seed, idx: UInt32(0), time: time, network: network, hops: hopsJSONString, payload: finalData)
            var onionAsArray = [UInt8](repeating: 0, count: onion.count)

            // Use withUnsafeBytes to copy the Data into the UInt8 array
            onion.withUnsafeBytes { bufferPointer in
                guard let baseAddress = bufferPointer.baseAddress else {
                    fatalError("Failed to get the base address")
                }
                memcpy(&onionAsArray, baseAddress, onion.count)
                self.mqtt.publish(
                    CocoaMQTTMessage(
                        topic: "\(myOkKey)/0/req/send",
                        payload: onionAsArray
                    )
                )
            }

        } catch {
            return SphinxMsgError.encodingError
        }

        return nil
    }
    
}


//MARK: Helper Structs & Functions:

// Parsing Helper Struct
struct SphinxOnionBrokerResponse: Mappable {
    var scid: String?
    var serverPubkey: String?
    var myPubkey: String?

    init?(map: Map) {}

    mutating func mapping(map: Map) {
        scid <- map["scid"]
        serverPubkey <- map["server_pubkey"]
    }
}

struct SphinxMsgContent{
    var content:String
}

struct SphinxChatMsg {
    // Define your struct fields here
    // For example:
    var message: SphinxMsgContent
    var sender: String
    var type: UInt8
}

enum SphinxMsgTypes: UInt8{
    case KeyExchange = 10
    case KeyExchangeConfirmation = 11
}

enum SphinxMsgError: Error {
    case encodingError
    case credentialsError //can't get access to my Private Keys/other data!
    case contactDataError // not enough data about contact!
}

func serializeChatMsg(msg: SphinxChatMsg) -> Result<Data, SphinxMsgError> {
    var buff = Data()

    do {
        try encodeMapLength(&buff, length: 4) // Increase the length by 1 for uuid
        try encodeString(&buff, string: "m")
        try serializeMessageContent(&buff, messageContent: msg.message)
        try encodeString(&buff, string: "s")
        try serializeSender(&buff, sender: msg.sender)
        try encodeString(&buff, string: "t")
        try encodeUInt8(&buff, value: msg.type)
        //try encodeString(&buff, string: "u") // Serialize uuid
        //try encodeUUID(&buff, uuid: msg.uuid) // Custom function to serialize UUID

        return .success(buff)
    } catch {
        return .failure(.encodingError)
    }
}

func serializeMessageContent(_ buffer: inout Data, messageContent: SphinxMsgContent) throws {
    // Implement your serialization logic for message content here
    // Example:
    try encodeString(&buffer, string: messageContent.content)
}

func encodeUUID(_ buffer: inout Data, uuid: String) throws {
    // Convert UUID string to UUID object
    guard let uuidObject = UUID(uuidString: uuid) else {
        throw SphinxMsgError.encodingError
    }

    // Convert UUID object to Data
    var uuidBytes = uuidObject.uuid
    let uuidData = withUnsafeBytes(of: &uuidBytes) {
        Data($0)
    }

    // Append the UUID data to the buffer
    buffer.append(uuidData)
}



func encodeMapLength(_ buffer: inout Data, length: Int) throws {
    // Implement your encoding logic for map length here
    // Example:
    var length = length
    buffer.append(Data([UInt8(length)]))
}

func encodeString(_ buffer: inout Data, string: String) throws {
    // Implement your encoding logic for strings here
    // Example:
    let data = string.data(using: .utf8)
    buffer.append(data!)
}

func serializeMessage(_ buffer: inout Data, message: String) throws {
    // Implement your serialization logic for message here
    // Example:
    try encodeString(&buffer, string: message)
}

func serializeSender(_ buffer: inout Data, sender: String) throws {
    // Implement your serialization logic for sender here
    // Example:
    try encodeString(&buffer, string: sender)
}

func encodeUInt8(_ buffer: inout Data, value: UInt8) throws {
    // Implement your encoding logic for UInt8 here
    // Example:
    var value = value
    buffer.append(Data([value]))
}

